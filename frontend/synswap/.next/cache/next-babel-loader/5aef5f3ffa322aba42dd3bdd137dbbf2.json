{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport axios from \"axios\";\n/**\n * @function createRows\n * @param data\n * @param fields\n * takes data and maps each field to corresponding data input\n */\n\nexport var createRows = function createRows(data, fields) {\n  var result = [];\n\n  for (var i = 0; i < fields.length; i++) {\n    var row = [fields[i], data[i]];\n    result.push(row);\n  }\n\n  return result;\n};\nexport var generateInitial = function generateInitial(array, values) {\n  var result = {};\n\n  for (var i = 0; i < array.length; i++) {\n    result = _objectSpread({}, result, _defineProperty({}, array[i][0], values[i]));\n  }\n\n  return result;\n};\nexport var tradeSchema = function tradeSchema(schema, values) {\n  var generateSchema = function generateSchema(object, values) {\n    var keys = _Object$keys(object);\n\n    var valueCount = 0;\n    var result = {};\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var obj = object[key];\n\n      if (typeof obj === 'string' || typeof obj === 'number') {\n        result = _objectSpread({}, result, _defineProperty({}, key, values[valueCount]));\n        valueCount++;\n      } else {\n        result = _objectSpread({}, result, _defineProperty({}, key, generateSchema(obj, values.slice(valueCount, valueCount + _Object$keys(object).length))));\n        valueCount = valueCount + _Object$keys(object).length;\n      }\n    }\n\n    return result;\n  };\n\n  return generateSchema(schema, values);\n};\nexport var fetchTrades =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(params) {\n    var url, response, newNotifications;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            url = \"http://localhost:4000/api/updates/\" + params.blocknumber + \"?traderid=\" + params.traderid;\n            _context.prev = 1;\n            _context.next = 4;\n            return axios.get(url);\n\n          case 4:\n            response = _context.sent;\n\n            if (response.data.success && response.data.trades) {\n              params.dispatch({\n                type: 'FETCH_TRADES',\n                payload: {\n                  trades: response.data.trades,\n                  blocknumber: response.data.blocknumber\n                }\n              });\n              newNotifications = response.data.trades.map(function (trade) {\n                // TODO: Only new trade notifcations currently, currently cannot amend trades.\n                return {\n                  message: \"Amount: \" + trade.amount + \" Type: \" + trade.tradeType,\n                  title: \"New trade with \" + trade.counterPartyId + \" alleged\"\n                };\n              });\n              newNotifications.length && newNotifications[newNotifications.length - 1] !== params.notifications[params.notifications.length - 1] ? params.dispatch({\n                type: 'ADD_NOTIFICATIONS',\n                payload: newNotifications\n              }) : null;\n            }\n\n            _context.next = 11;\n            break;\n\n          case 8:\n            _context.prev = 8;\n            _context.t0 = _context[\"catch\"](1);\n            console.log(_context.t0);\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[1, 8]]);\n  }));\n\n  return function fetchTrades(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var initialFetch =\n/*#__PURE__*/\nfunction () {\n  var _ref2 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(dispatch) {\n    var url, response;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            url = \"http://localhost:4000/api/traders/1/trades\";\n            _context2.prev = 1;\n            _context2.next = 4;\n            return axios.get(url);\n\n          case 4:\n            response = _context2.sent;\n            dispatch({\n              type: 'INITIAL_FETCH',\n              payload: {\n                trades: response.data.trades,\n                blocknumber: response.data.blocknumber\n              }\n            });\n            _context2.next = 11;\n            break;\n\n          case 8:\n            _context2.prev = 8;\n            _context2.t0 = _context2[\"catch\"](1);\n            console.log(_context2.t0);\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[1, 8]]);\n  }));\n\n  return function initialFetch(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nexport var handleSubmit =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3(params) {\n    var url, data;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            url = 'http://localhost:4000/api/traders/1/trades';\n            data = params.values; //tradeSchema(params.schema, Object.values(params.values));\n\n            console.log(data);\n            _context3.prev = 3;\n            axios.post(url, {\n              data: data\n            }).then(function (response) {\n              if (response.status === 200) {\n                console.log(response);\n                params.dispatch({\n                  type: 'NEW_TRADE',\n                  payload: [response.data.data, data]\n                });\n                return response.data;\n              } else {\n                console.log('Trade register failed.', response.status);\n                var error = new Error(response.statusText);\n                error.response = response;\n                throw error;\n              }\n            });\n            _context3.next = 11;\n            break;\n\n          case 7:\n            _context3.prev = 7;\n            _context3.t0 = _context3[\"catch\"](3);\n            console.error('You have an error in your code or there are Network issues.', _context3.t0);\n            return _context3.abrupt(\"return\", _context3.t0);\n\n          case 11:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[3, 7]]);\n  }));\n\n  return function handleSubmit(_x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/jjmacakiage/dev/synswap-rates-platform/frontend/synswap/js/tradehelpers.js"],"names":["axios","createRows","data","fields","result","i","length","row","push","generateInitial","array","values","tradeSchema","schema","generateSchema","object","keys","valueCount","key","obj","slice","fetchTrades","params","url","blocknumber","traderid","get","response","success","trades","dispatch","type","payload","newNotifications","map","trade","message","amount","tradeType","title","counterPartyId","notifications","console","log","initialFetch","handleSubmit","post","then","status","error","Error","statusText"],"mappings":"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","sourcesContent":["import axios from \"axios\";\n\n/**\n * @function createRows\n * @param data\n * @param fields\n * takes data and maps each field to corresponding data input\n */\nexport const createRows = (data, fields) => {\n    const result = [];\n    for (let i = 0; i < fields.length; i++) {\n        const row = [fields[i], data[i]];\n        result.push(row);\n    }\n    return result;\n};\n\nexport const generateInitial = (array, values) => {\n    let result = {};\n    for (let i = 0; i < array.length; i++) {\n        result = {...result, [array[i][0]]: values[i]};\n    }\n    return result;\n};\n\nexport const tradeSchema = (schema, values) => {\n    const generateSchema = (object, values) => {\n        let keys = Object.keys(object);\n        let valueCount = 0;\n        let result = {};\n        for (let i = 0; i < keys.length; i++) {\n            let key = keys[i];\n            let obj = object[key];\n            if (typeof obj === 'string' || typeof obj === 'number') {\n                result = { ...result, [key]: values[valueCount]};\n                valueCount++;\n            }\n            else {\n                result = { ...result, [key]: generateSchema(obj, values.slice(valueCount, valueCount + Object.keys(object).length))};\n                valueCount = valueCount + Object.keys(object).length\n            }\n        }\n        return result;\n    };\n    return generateSchema(schema, values)\n};\n\nexport const fetchTrades = async params => {\n    const url = \"http://localhost:4000/api/updates/\" + params.blocknumber + \"?traderid=\" + params.traderid;\n    try {\n        const response = await axios.get(url);\n        if(response.data.success && response.data.trades) {\n            params.dispatch({\n                type: 'FETCH_TRADES',\n                payload: {\n                    trades: response.data.trades,\n                    blocknumber: response.data.blocknumber\n                }\n            });\n            const newNotifications = response.data.trades.map((trade) => {\n                // TODO: Only new trade notifcations currently, currently cannot amend trades.\n                return {message: \"Amount: \" + trade.amount + \" Type: \" + trade.tradeType, title: \"New trade with \" + trade.counterPartyId +\" alleged\"};\n            });\n            (newNotifications.length && newNotifications[newNotifications.length - 1] !== params.notifications[params.notifications.length - 1]) ?\n                params.dispatch({\n                    type: 'ADD_NOTIFICATIONS',\n                    payload: newNotifications\n                }) : null\n        }\n\n    } catch (e) {\n        console.log(e);\n    }\n};\n\nexport const initialFetch = async dispatch => {\n    const url = \"http://localhost:4000/api/traders/1/trades\";\n    try {\n        const response = await axios.get(url);\n        dispatch({\n            type: 'INITIAL_FETCH',\n            payload: {\n                trades: response.data.trades,\n                blocknumber: response.data.blocknumber\n            }\n        });\n\n    } catch (e) {\n        console.log(e);\n    }\n};\n\n export const handleSubmit = async params => {\n    const url = 'http://localhost:4000/api/traders/1/trades';\n    const data = params.values; //tradeSchema(params.schema, Object.values(params.values));\n     console.log(data);\n    try {\n        axios.post(url, {\n            data\n        })\n            .then(function (response) {\n                if (response.status === 200) {\n                    console.log(response);\n                    params.dispatch({ type: 'NEW_TRADE', payload: [response.data.data, data] });\n                    return response.data;\n                } else {\n                    console.log('Trade register failed.', response.status);\n                    let error = new Error(response.statusText);\n                    error.response = response;\n                    throw error\n                }\n            });\n    } catch (error) {\n        console.error(\n            'You have an error in your code or there are Network issues.',\n            error\n        );\n        return error;\n    }\n};\n"]},"metadata":{},"sourceType":"module"}